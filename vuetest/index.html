<!DOCTYPE html>
<html>
<head>
	<title></title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/vuex/2.1.1/vuex.min.js"></script>
	<script type="text/javascript">
		var genRandomString = (l=20) => _.fill(Array(l), null)
			.map(x=>String.fromCharCode(97+_.random(24)))
			.join('');
		
		var genPortal = function() {
			var id = genRandomString(); 
			return {
				id: id,
				name: 'name_' + id,
				description: 'This is portal name_' + id
			}
		}

		var genMockData = function() {
			var data = {
				db: {
					tags: [],
					portals: []
				},
				ui: {
					isBlocked: false
				}
			}
		};

		

		var getRandomPortal = function(portals) {
			return portals[_.random(portals.length-1)];
		}

		

		var genTag = function(portals) {
			var tagName = genRandomString();
			var tagId = genRandomString(8);
			var res = {
				id: tagId,
				name: tagName,
				redirectTo: null,
				description: 'sdffsd dsfdfs  dsf 32 3e2 e2f',
				portals: []
			}
			var linkedPortalsNo = _.random(6);
			for(let l1=0; l1 < linkedPortalsNo; l1++) {
				var portal = getRandomPortal(portals);
				var tagPortal = {
					portalId: portal.id,
					tagDescription: portal.name + " portal[" +  portal.id + "] description for tag " + tagName + " with id " + tagId
				};
				res.portals.push(tagPortal);
			};
			return res;
		}

		var genMockData = function() {
			var data = {
				db: {
					tags: [],
					portals: []
				},
				ui: {
					isBlocked: false,
					textFilter: ""
				}
			};
			_.each(Array(5000), function() {
				data.db.portals.push(genPortal());
			});
			_.each(Array(20000), function() {
				data.db.tags.push(genTag(data.db.portals));
			});
			return data;
		};
		
		var state = genMockData();


	</script>
</head>
<body>
<div id="app">
  	<div>Portals: {{ $store.state.db.portals.length }}, Tags: {{ $store.state.db.tags.length }}, Ilosc par tagPortal: {{ $store.getters.calculatePortalTagsPairs }}</div>
  	<div>{{ $store.state.ui.isBlocked ? "TAK" : "NIE" }}</div>
	<button v-on:click="buttonClickRemovePortal">Remove portal - najbardziej obciazajaca obliczeniowo operacja jaka mozna sobie wyobrazic - celowo zaimplementowana srednio efektywnie</button>
		<button v-on:click="buttonClickRemoveTag">Remove tag</button>
		<button v-on:click="buttonClickRemoveRandomTag">removeRandomTag</button>
	<button v-on:click="calculatePortalTagsPairs">calculatePortalTagsPair</button>
	<button v-on:click="clickSortTags" disabled>sort tags</button>
	<input v-on:keyup="changeRegexpFilter" placeholder="filter" :value="$store.state.ui.textFilter">
	<test-component v-bind:mydata="$store.getters.calculatePortalTagsPairs" v-bind:tagslist="$store.state.db.tags">
	</test-component>
</div>
<script>
	Vue.component('test-component', {
		data: function () {
			return { count: 0 }
		},
		props: ['mydata', 'tagslist'],
		computed: {
			filteredtags: function() {
				if (this.$store.state.ui.textFilter && this.$store.state.ui.textFilter.length) {
					var regExp = new RegExp(this.$store.state.ui.textFilter);
				} else {
					regExp = {
						test: x=>true
					}
				}
				return this.tagslist.filter(function(tag) {
					return regExp.test(tag.id);
				});
			}
		},
		//template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
		template: "<div>Blablabla \
			<div v-for='tag in filteredtags' :key='tag.id'> \
			{{tag.id}} \
			<span style='color:red' v-on:click='removeTag(tag)'>usun</span>    \
			<span style='color:green' v-on:click='showTag(tag)'>pokaz</span>    \
			</div>								\
		</div>",
		'methods': {
			'removeTag': function(tag) {
			    this.$store.commit('removeTag', tag.id);
			},
			'showTag': function(tag) {
				alert(JSON.stringify(tag, '\n', null));
			}
		}
	});


	app = new Vue({
		'el': '#app',
		'store': new Vuex.Store({
			state: state,
			getters: {
			    calculatePortalTagsPairs: function(state) {
			    	var res = 0;
					state.db.tags.forEach(function(tag) {
						res+=Object.keys(tag.portals).length||0;
					});
					return res;
					// alert(res);
			    }
			},
			mutations: {
				increment (state) {
				    state.count++
				}, removeLastPortal: function(state) {
				    var portal = state.db.portals.pop();
				    state.ui.isBlocked = !state.ui.isBlocked;
				    state.db.tags.forEach(function(tag) {
				    	var hasPortalWithGivenId = false;
				    	tag.portals.forEach(tagPortal => void( hasPortalWithGivenId = tagPortal.portalId || hasPortalWithGivenId ));
				    	if (hasPortalWithGivenId) {
				    		tag.portals = tag.portals.filter(function(tagPortal) {	
				    			return tagPortal.portalId != portal.id;
				    		});
				    	}
				    });
				}, removeRandomTag: function(state) {
				    state.db.tags.splice(_.random(state.db.tags.length-1), 1); // mutates array
				    state.ui.isBlocked = !state.ui.isBlocked;
				}, removeLastTag: function(state) {
				    state.db.tags.pop();
				    state.ui.isBlocked = !state.ui.isBlocked;
				},
				removeTag: function(state, tagId) {
				    var tagIndex = state.db.tags.findIndex(lTag => lTag.id == tagId)
				    console.log(tagId);
				    console.log(tagIndex);
				    if (tagIndex != -1) {

				    	state.db.tags.splice(tagIndex, 1); // mutates array
				    	state.ui.isBlocked = !state.ui.isBlocked;
				    }
				},
				orderBy: function(state, orderFunction) {
					console.log('1');
				    orderFunction = orderFunction || (tag => tag.id.charCodeAt(0)*300 + tag.id.charCodeAt(1));
				    // state.db.tags.forEach(x=>void(console.log.bind(console)(x.id, orderFunction(x))));
				    state.db.tags = _.orderBy(state.db.tags, orderFunction);
				    console.log('2');
				},
				uiUpdateFilterText: function(state, newFilterText) {
					state.ui.textFilter = newFilterText;
				}

			}
		}),
		'methods': {
			'buttonClickRemovePortal': function() {
			    this.$store.commit('removeLastPortal');
			},
			'buttonClickRemoveTag': function() {
			    this.$store.commit('removeLastTag');
			},
			'calculatePortalTagsPairs': function() {
				alert(this.$store.getters.calculatePortalTagsPairs);
			},
			'buttonClickRemoveRandomTag': function() {
				this.$store.commit('removeRandomTag');	
			},
			'clickSortTags': function() {
				var fragment = prompt('Podaj czesc tagu');
				var regExp;
				regExp = new RegExp(fragment);
				console.log(fragment, regExp);
				if (fragment && fragment.length) {
					// alert('not implemented');
					// return;
					this.$store.commit('orderBy', function(tag) {
						// console.log( tag.name );
						return regExp.test(tag.id) ? -1 - tag.portals.length : 0;
					});
				} else {
					this.$store.commit('orderBy');
				}
			},
			changeRegexpFilter: function(event) {
				this.$store.commit("uiUpdateFilterText", event.target.value);

			}
		}
	});


</script>
</body>
</html>